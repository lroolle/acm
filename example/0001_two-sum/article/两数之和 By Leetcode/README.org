#+TITLE: 两数之和
#+DATE: 2020-10-11 13:38
#+LAST_MODIFIED: 2020-10-11 13:38
#+STARTUP: overview
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t
#+EXPORT_FILE_NAME: 0001-two-sum-liang-shu-zhi-he-by-leetcode-solution
#+HUGO_BASE_DIR:~/G/blog
#+HUGO_SECTION: leetcode
#+HUGO_CATEGORIES:leetcode
#+HUGO_TAGS: Leetcode Algorithms C C++ Go Java Python Array HashTable

* [[https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/][两数之和]] :C:C++:Go:Java:Python:Array:HashTable:
:PROPERTIES:
:VISIBILITY: children
:END:

#+begin_quote
[[https://leetcode-cn.com/problems/two-sum/][0001. Two Sum]] [[https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/][两数之和]] solution by [[https://leetcode-cn.com/u/leetcode-solution/][LeetCode-Solution]]
#+end_quote

** 方法一：暴力枚举
     :PROPERTIES:
     :CUSTOM_ID: 方法一暴力枚举
     :END:

*思路及算法*

最容易想到的方法是枚举数组中的每一个数 =x=，寻找数组中是否存在
=target - x=。

当我们使用遍历整个数组的方式寻找 =target - x= 时，需要注意到每一个位于
=x= 之前的元素都已经和 =x=
匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在
=x= 后面的元素中寻找 =target - x=。

*代码*

#+BEGIN_SRC java
  class Solution {
      public int[] twoSum(int[] nums, int target) {
          int n = nums.length;
          for (int i = 0; i < n; ++i) {
              for (int j = i + 1; j < n; ++j) {
                  if (nums[i] + nums[j] == target) {
                      return new int[]{i, j};
                  }
              }
          }
          return new int[0];
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
  class Solution {
  public:
      vector<int> twoSum(vector<int>& nums, int target) {
          int n = nums.size();
          for (int i = 0; i < n; ++i) {
              for (int j = i + 1; j < n; ++j) {
                  if (nums[i] + nums[j] == target) {
                      return {i, j};
                  }
              }
          }
          return {};
      }
  };
#+END_EXAMPLE

#+BEGIN_SRC C
  int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
      for (int i = 0; i < numsSize; ++i) {
          for (int j = i + 1; j < numsSize; ++j) {
              if (nums[i] + nums[j] == target) {
                  int* ret = malloc(sizeof(int) * 2);
                  ret[0] = i, ret[1] = j;
                  *returnSize = 2;
                  return ret;
              }
          }
      }
      *returnSize = 0;
      return NULL;
  }
#+END_SRC

#+BEGIN_SRC python
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          n = len(nums)
          for i in range(n):
              for j in range(i + 1, n):
                  if nums[i] + nums[j] == target:
                      return [i, j]
          
          return []
#+END_SRC

#+BEGIN_EXAMPLE
  func twoSum(nums []int, target int) []int {
      for i, x := range nums {
          for j := i + 1; j < len(nums); j++ {
              if x+nums[j] == target {
                  return []int{i, j}
              }
          }
      }
      return nil
  }
#+END_EXAMPLE

*复杂度分析*

- 时间复杂度：$O(N^2)$，其中 $N$
  是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。

- 空间复杂度：$O(1)$。

** 方法二：哈希表
     :PROPERTIES:
     :CUSTOM_ID: 方法二哈希表
     :END:

*思路及算法*

注意到方法一的时间复杂度较高的原因是寻找 =target - x=
的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 =target - x= 的时间复杂度降低到从 $O(N)$ 降低到
$O(1)$。

这样我们创建一个哈希表，对于每一个 =x=，我们首先查询哈希表中是否存在
=target - x=，然后将 =x= 插入到哈希表中，即可保证不会让 =x= 和自己匹配。

*代码*

#+BEGIN_SRC java
  class Solution {
      public int[] twoSum(int[] nums, int target) {
          Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
          for (int i = 0; i < nums.length; ++i) {
              if (hashtable.containsKey(target - nums[i])) {
                  return new int[]{hashtable.get(target - nums[i]), i};
              }
              hashtable.put(nums[i], i);
          }
          return new int[0];
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
  class Solution {
  public:
      vector<int> twoSum(vector<int>& nums, int target) {
          unordered_map<int, int> hashtable;
          for (int i = 0; i < nums.size(); ++i) {
              auto it = hashtable.find(target - nums[i]);
              if (it != hashtable.end()) {
                  return {it->second, i};
              }
              hashtable[nums[i]] = i;
          }
          return {};
      }
  };
#+END_EXAMPLE

#+BEGIN_SRC C
  struct hashTable {
      int key;
      int val;
      UT_hash_handle hh;
  };

  struct hashTable* hashtable;

  struct hashTable* find(int ikey) {
      struct hashTable* tmp;
      HASH_FIND_INT(hashtable, &ikey, tmp);
      return tmp;
  }

  void insert(int ikey, int ival) {
      struct hashTable* it = find(ikey);
      if (it == NULL) {
          struct hashTable* tmp = malloc(sizeof(struct hashTable));
          tmp->key = ikey, tmp->val = ival;
          HASH_ADD_INT(hashtable, key, tmp);
      } else {
          it->val = ival;
      }
  }

  int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
      hashtable = NULL;
      for (int i = 0; i < numsSize; i++) {
          struct hashTable* it = find(target - nums[i]);
          if (it != NULL) {
              int* ret = malloc(sizeof(int) * 2);
              ret[0] = it->val, ret[1] = i;
              *returnSize = 2;
              return ret;
          }
          insert(nums[i], i);
      }
      *returnSize = 0;
      return NULL;
  }
#+END_SRC

#+BEGIN_SRC python
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          hashtable = dict()
          for i, num in enumerate(nums):
              if target - num in hashtable:
                  return [hashtable[target - num], i]
              hashtable[nums[i]] = i
          return []
#+END_SRC

#+BEGIN_EXAMPLE
  func twoSum(nums []int, target int) []int {
      hashTable := map[int]int{}
      for i, x := range nums {
          if p, ok := hashTable[target-x]; ok {
              return []int{p, i}
          }
          hashTable[x] = i
      }
      return nil
  }
#+END_EXAMPLE

*复杂度分析*

- 时间复杂度：$O(N)$，其中 $N$ 是数组中的元素数量。对于每一个元素
  =x=，我们可以 $O(1)$ 地寻找 =target - x=。

- 空间复杂度：$O(N)$，其中 $N$ 是数组中的元素数量。主要为哈希表的开销。
